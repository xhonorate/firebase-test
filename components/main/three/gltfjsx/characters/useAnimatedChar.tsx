/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useCallback, useEffect, useMemo, useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import { GroupProps, useGraph } from "@react-three/fiber";
import { SkeletonUtils } from "three-stdlib";
import { CharacterType } from "./Parts/useParts";
import useParts from "./Parts/useParts";

type GLTFResult = GLTF & {
  nodes: {
    PrototypePete: THREE.SkinnedMesh;
    Body: THREE.Bone;
    Head: THREE.Bone;
    armLeft: THREE.Bone;
    armRight: THREE.Bone;
    handSlotLeft: THREE.Bone;
    handSlotRight: THREE.Bone;
  };
  materials: {
    PrototypePete: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export type ActionName =
  | "Attack(1h)"
  | "AttackCombo"
  | "AttackSpinning"
  | "BasePose"
  | "Block"
  | "Cheer"
  | "Climbing"
  | "Dance"
  | "DashBack"
  | "DashFront"
  | "DashLeft"
  | "DashRight"
  | "Defeat"
  | "HeavyAttack"
  | "Hop"
  | "Idle"
  | "Interact"
  | "Jump"
  | "LayingDownIdle"
  | "PickUp"
  | "Roll"
  | "Run"
  | "Shoot(1h)"
  | "Shoot(2h)"
  | "Shoot(2h)Bow"
  | "Shooting(1h)"
  | "Shooting(2h)"
  | "Throw"
  | "Walk"
  | "Wave";
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

export interface Equipment {
  head?: JSX.Element;
  body?: JSX.Element;
  armLeft?: JSX.Element;
  armRight?: JSX.Element;
  handSlotLeft?: JSX.Element;
  handSlotRight?: JSX.Element;
}

export default function useAnimatedChar(
  character: CharacterType,
  equipment: Equipment = null
) {
  const group = useRef<THREE.Group>();
  const action = useRef<ActionName>("Idle"); //current animation playing
  const callback = useRef<() => void>(null); //action to occur on anim complete

  const parts = useParts(character);

  const { scene, animations } = useGLTF(
    "/assets/kaykit/Models/characters/AnimatedCharacter.gltf.glb"
  ) as any as GLTFResult;

  // Clone skeleton (https://codesandbox.io/s/react-three-fiber-wildlife-nrbnq?file=/src/Model.js)
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  // TODO: try to clone just what is neccessary (not the whole skinned mesh)
  const { nodes: bones } = useGraph(clone);

  const { actions, mixer } = useAnimations<GLTFAction>(animations, group);

  const play = useCallback(
    (anim: ActionName = "Idle", loop = true) =>
      new Promise<void>((resolve) => {
        // Instantly do anything waiting for previous anims
        if (callback.current) {
          console.log("useAnimatedChar - play - Resolve Previous");
          const prevCallback = callback.current;
          callback.current = null;
          prevCallback();
        }

        if (!actions[anim].isRunning()) {
          if (action.current && action.current !== anim) {
            // TODO: Animation blending depending on which two are being interpolated
            actions[action.current].crossFadeTo(actions[anim], 1, true).stop();
          }
          actions[anim].setLoop(loop ? 1 : 0, loop ? Infinity : 0).play();
          action.current = anim;

          if (loop) {
            // Should not wait on loops (since it will go forever) resolve instantly
            resolve();
          } else {
            // Wait for animation to complete, then resolve async
            callback.current = resolve;
          }
        } else {
          // If animation is already running, resolve instantly
          resolve();
        }
      }),
    [actions]
  );

  // Attatch event listeners
  useEffect(() => {
    const onAnimComplete = (e: any) => {
      // If a next action is queued - move queue forward
      if (callback.current) {
        console.log("Anim Complete")
        callback.current();
        callback.current = null;
      }
    };

    if (!mixer.hasEventListener("finished", onAnimComplete)) {
      // Listener for animations completed
      mixer.addEventListener("finished", onAnimComplete);
    }

    return () => {
      // Remove listener on unmount
      callback.current = null;
      mixer.removeEventListener("finished", onAnimComplete);
    };
  }, [mixer, play]);

  // Import Parts for character type, then place them within respective bone primatives
  // TODO: should this be useMemo or not? idk check for mem leaks ----- I think its good?
  const Model = useMemo(() => {
    return (
      <group ref={group} dispose={null}>
        <primitive object={bones.Body}>
          {parts.body}
          {equipment?.body}

          <primitive object={bones.Head}>
            {parts.head}
            {equipment?.head}
            {/* TODO: custom heads! just include <KnightHeadA /> here */}
          </primitive>

          <primitive object={bones.armLeft}>
            <group
              position={[0, 0.1, -0.03]}
              rotation={[0, (3 * Math.PI) / 2, 0.85 * Math.PI]}
            >
              {parts.armLeft}
              {equipment?.armLeft}
            </group>

            <primitive object={bones.handSlotLeft}>
              {equipment?.handSlotLeft}
            </primitive>
          </primitive>

          <primitive object={bones.armRight}>
            <group
              position={[0, 0.1, 0.03]}
              rotation={[0, (3 * Math.PI) / 2, -0.85 * Math.PI]}
            >
              {parts.armRight}
              {equipment?.armRight}
            </group>

            <primitive object={bones.handSlotRight}>
              {equipment?.handSlotRight}
            </primitive>
          </primitive>
        </primitive>
      </group>
    );
  }, [bones, equipment, parts]);

  return {
    Model,
    play,
  };
}

useGLTF.preload("/assets/kaykit/Models/characters/AnimatedCharacter.gltf.glb");
